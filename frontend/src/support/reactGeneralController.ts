import stateSubscriberEntry from "./stateSubscriberEntry";

/**
 * Just general properties any single useState controller would need.
 * Main selling point is ability to update several components far across
 * as long as they subscribe to controller on mount
 * */
abstract class ReactGeneralController<T> {
  protected subscribers: stateSubscriberEntry<T>[];
  protected updateView(newValue: T): void {
    for (let subscribers of this.subscribers) {
      subscribers[1](newValue);
    }
  }
  /**
   * Updates all subsribed setState functions with new value
   * @param {T} newValue new state value
   */
  updateModel(newValue: T) {
    this.updateView(newValue);
  }
  /**
   * Attaches the observing component to this controller
   * @param {string} name name of new subscriber
   * @param {React.Dispatch<React.SetStateAction<T>>} stateFun react setState function generated by {@link React.useState}
   */
  subscribeView(
    name: string,
    stateFun: React.Dispatch<React.SetStateAction<T>>
  ): void {
    this.subscribers.push([name, stateFun]);
  }
  /**
   * Detaches the observing component
   * @param {string} name subscriber to detach
   */
  unsubscribeView(name: string) {
    const indexToRemove = this.subscribers.findIndex((entry) => {
      entry[0] === name;
    });
    if (indexToRemove > -1) this.subscribers.splice(indexToRemove, 1);
  }

  constructor() {
    this.subscribers = [];
  }
}
export default ReactGeneralController;
